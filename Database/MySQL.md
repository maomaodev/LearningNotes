共享锁（shared lock）也叫读锁（read lock）

排他锁（exclusive lock）也叫写锁（write lock）



锁策略就是在锁的开销和数据的安全性之间寻求平衡。

**表锁（table lock）**：MySQL 中最基本的锁策略，开销最小。在特定的场景中，表锁也可能有良好的性能。尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE 之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁（row-level lock）**：最大程度支持并发处理，开销最大。行级锁只在存储引擎层实现，MySQL 服务器层没有实现。



事务就是一组原子性的SQL查询。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。ACID表示原子性
(atomicity)、一致性 (consistency)、 隔离性(isolation) 和持久性(durability)。 

**原子性(atomicity)**
一个事务必须被视为-一个不可分割的最小工作单元，整个事务中的所有操作要么全
部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分
操作，这就是事务的原子性。

**一致性 (consistency)**
数据库总是从一个一致性的状态转换到另外一个- -致性的状态。在前面的例子中,
一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损
失200美元，因为事务最终没有提交,所以事务中所做的修改也不会保存到数据库中。

**隔离性(isolation)**
通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面
的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外一个账户汇
总程序开始运行，则其看到的支票账户的余额并没有被减去200美元。后面我们讨
论隔离级别(Isolationlevel)的时候，会发现为什么我们要说“通常来说”是不可见的。
**持久性(durability)**
一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修
改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多
不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且
不可能有能做到100%的持久性保证的策略(如果数据库本身就能做到真正的持久



4种隔离级别：READ UNCOMMITTED (未提交读)、READ COMMITTED (提交读)、REPEATABLE READ (可重复读)、SERIALIZABLE (可串行化)。MySQL可以通过执行SET
TRANSACTION ISOLATION LEVEL命令来设置隔离级别。

MySQL提供了两种事务型的存储引擎: InnoDB和NDB Cluster。MySQL默认采用自动提交(AUTOCOMMIT) 模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式:

